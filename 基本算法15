15. 在一个果园里，小明已经将所有的水果打了下来，并按水果的不同种类分成了若干堆，小明决定把所有的水果合成一堆。每一次合并，小明可以把两堆水果合并到一起，
消耗的体力等于两堆水果的重量之和。当然经过 n‐1 次合并之后，就变成一堆了。小明在合并水果时总共消耗的体力等于每次合并所耗体力之和。     假定每个水果重量
都为 1，并且已知水果的种类数和每种水果的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费值。例如有 3 种水果，数目依
次为 1，2，9。可以先将 1，2 堆合并，新堆数目为3，耗费体力为 3。然后将新堆与原先的第三堆合并得到新的堆，耗费体力为 12。所以小明总共耗费体力=3+12=15，
可以证明 15 为最小的体力耗费值。
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0) break;
        int a[n];
        int res=0;
        for(int i=0;i<n;i++)
            cin>>a[i];
        for(int i=0;i<n-1;i++)
        {
            sort(a,a+n);
            for(int j=0;j<n;j++)
                if(a[j]!=0)
                {
                    res=res+a[j]+a[j+1];
                    a[j+1]=a[j+1]+a[j];
                    a[j]=0;
                    break;
                }
        }
        cout<<res<<endl;
    }
    return 0;
}
答题思路：这题我这个解决方法过了，但是时间复杂度很大，我自己列了几组数据之后发现，如果要使出力最少，就是必须每次将重量最小的两堆和在一起，而且必须操作n-1次才能将n堆和在一起。
